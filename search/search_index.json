{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"FeynGraph","text":"<p>FeynGraph is a modern Feynman diagram generation toolkit aiming to be as versatile as possible while remaining pleasant to use. The library itself is written in Rust, additional language bindings are available for Python and Wolfram Mathematica.</p>"},{"location":"#installation","title":"Installation","text":"Python Rust Mathematica <p>The FeynGraph Python bindings are published to PyPI and can therefore easily installed with e.g. <code>pip</code> <pre><code>pip install feyngraph\n</code></pre> In addition to the library interface, there is also a more classical command line utility. This requires some extra dependencies, which can be installed with e.g. <pre><code>pip install feyngraph[cli]\n</code></pre></p> <p>To use FeynGraph in a Rust project, it can simply be added to the project with <pre><code>cargo add feyngraph\n</code></pre> or be manually added to <code>Cargo.toml</code> as <pre><code>[dependencies]\nfeyngraph = \"0.1\"\n</code></pre></p> <p>FeynGraph includes experimental Wolfram Mathematica bindings which use Mathematica's <code>ExternalEvaluate</code> system to call the FeynGraph Python library. To use the interface, make sure to configure a Python environment in which FeynGraph is installed as described here. Then, running <pre><code>ExternalEvaluate[\"Python\", \"import feyngraph; feyngraph.import_wolfram()\"] // ToExpression\n</code></pre> imports the FeynGraph Mathematica interface.</p>"},{"location":"#building-from-source","title":"Building From Source","text":"<p>The FeynGraph Python library can also easily be built from source, which requires a Rust toolchain and <code>maturin</code>. Then, in the cloned repository, a Python wheel can be compiled by running <pre><code>maturin build -r\n</code></pre> The library can also immediately be installed by running <pre><code>pip install .\n</code></pre></p>"},{"location":"reference/feyngraph/","title":"API Reference","text":"<p>Modules:</p> Name Description <code>feyngraph</code> <p>A modern Feynman diagram generation toolkit.</p> <code>topology</code> <code>wolfram</code> <p>Classes:</p> Name Description <code>Diagram</code> <p>The Feynman diagram class.</p> <code>DiagramContainer</code> <p>A container of Feynman diagrams and accompanying information</p> <code>DiagramGenerator</code> <p>The main class used to generate Feynman diagrams.</p> <code>DiagramSelector</code> <p>A selector class which determines whether a diagram is to be kept or to be discarded. Multiple criteria can</p> <code>InteractionVertex</code> <p>Internal representaion of an interaction vertex.</p> <code>Leg</code> <p>The class representing an external leg.</p> <code>Model</code> <p>Internal representation of a model in FeynGraph.</p> <code>Particle</code> <p>Internal representation of a particle in FeynGraph.</p> <code>Propagator</code> <p>The class representing an internal propagator.</p> <code>Topology</code> <p>The internal representation of a topology graph.</p> <code>TopologyModel</code> <p>A model containing only topological information, i.e. the allowed degrees of nodes.</p> <code>Vertex</code> <p>The class representing an internal vertex.</p> <p>Functions:</p> Name Description <code>generate_diagrams</code> <p>Convenience function for diagram generation. This function only requires the minimal set of input information,</p> <code>set_threads</code> <p>Set the number of threads FeynGraph will use. The default is the maximum number of available threads.</p>"},{"location":"reference/feyngraph/#feyngraph.Diagram","title":"<code>Diagram</code>","text":"<p>The Feynman diagram class.</p> <p>Methods:</p> Name Description <code>bridges</code> <p>Get a list of the bridge propagators.</p> <code>chord</code> <p>Get a list of the propagators belonging to the <code>index</code>-th loop.</p> <code>draw_svg</code> <p>Draw the diagram in SVG format and write the result to <code>file</code></p> <code>draw_tikz</code> <p>Draw the diagram in TikZ (TikZiT) format and write the result to <code>file</code></p> <code>incoming</code> <p>Get a list of the incoming legs.</p> <code>loop_vertices</code> <p>Get a list of the vertices beloning to the <code>index</code>-th loop.</p> <code>n_ext</code> <p>Get  the number of external legs.</p> <code>n_in</code> <p>Get  the number of incoming external legs.</p> <code>n_out</code> <p>Get  the number of outgoing external legs.</p> <code>outgoing</code> <p>Get a list of the outgoing legs.</p> <code>propagator</code> <p>Get the propagator with index <code>index</code>.</p> <code>propagators</code> <p>Get a list of the internal propagators.</p> <code>sign</code> <p>Get the diagram's relative sign.</p> <code>symmetry_factor</code> <p>Get the diagram's symmetry factor.</p> <code>vertex</code> <p>Get the vertex with index <code>index</code>.</p> <code>vertices</code> <p>Get a list of the internal vertices.</p>"},{"location":"reference/feyngraph/#feyngraph.Diagram.bridges","title":"<code>bridges() -&gt; list[Propagator]</code>","text":"<p>Get a list of the bridge propagators.</p>"},{"location":"reference/feyngraph/#feyngraph.Diagram.chord","title":"<code>chord(index: int) -&gt; list[Propagator]</code>","text":"<p>Get a list of the propagators belonging to the <code>index</code>-th loop.</p>"},{"location":"reference/feyngraph/#feyngraph.Diagram.draw_svg","title":"<code>draw_svg(file: str)</code>","text":"<p>Draw the diagram in SVG format and write the result to <code>file</code></p>"},{"location":"reference/feyngraph/#feyngraph.Diagram.draw_tikz","title":"<code>draw_tikz(file: str)</code>","text":"<p>Draw the diagram in TikZ (TikZiT) format and write the result to <code>file</code></p>"},{"location":"reference/feyngraph/#feyngraph.Diagram.incoming","title":"<code>incoming() -&gt; list[Leg]</code>","text":"<p>Get a list of the incoming legs.</p>"},{"location":"reference/feyngraph/#feyngraph.Diagram.loop_vertices","title":"<code>loop_vertices(index: int) -&gt; list[Vertex]</code>","text":"<p>Get a list of the vertices beloning to the <code>index</code>-th loop.</p>"},{"location":"reference/feyngraph/#feyngraph.Diagram.n_ext","title":"<code>n_ext() -&gt; int</code>","text":"<p>Get  the number of external legs.</p>"},{"location":"reference/feyngraph/#feyngraph.Diagram.n_in","title":"<code>n_in() -&gt; int</code>","text":"<p>Get  the number of incoming external legs.</p>"},{"location":"reference/feyngraph/#feyngraph.Diagram.n_out","title":"<code>n_out() -&gt; int</code>","text":"<p>Get  the number of outgoing external legs.</p>"},{"location":"reference/feyngraph/#feyngraph.Diagram.outgoing","title":"<code>outgoing() -&gt; list[Leg]</code>","text":"<p>Get a list of the outgoing legs.</p>"},{"location":"reference/feyngraph/#feyngraph.Diagram.propagator","title":"<code>propagator(index: int) -&gt; Propagator</code>","text":"<p>Get the propagator with index <code>index</code>.</p>"},{"location":"reference/feyngraph/#feyngraph.Diagram.propagators","title":"<code>propagators() -&gt; list[Propagator]</code>","text":"<p>Get a list of the internal propagators.</p>"},{"location":"reference/feyngraph/#feyngraph.Diagram.sign","title":"<code>sign() -&gt; int</code>","text":"<p>Get the diagram's relative sign.</p>"},{"location":"reference/feyngraph/#feyngraph.Diagram.symmetry_factor","title":"<code>symmetry_factor() -&gt; int</code>","text":"<p>Get the diagram's symmetry factor.</p>"},{"location":"reference/feyngraph/#feyngraph.Diagram.vertex","title":"<code>vertex(index: int) -&gt; Vertex</code>","text":"<p>Get the vertex with index <code>index</code>.</p>"},{"location":"reference/feyngraph/#feyngraph.Diagram.vertices","title":"<code>vertices() -&gt; list[Vertex]</code>","text":"<p>Get a list of the internal vertices.</p>"},{"location":"reference/feyngraph/#feyngraph.DiagramContainer","title":"<code>DiagramContainer</code>","text":"<p>A container of Feynman diagrams and accompanying information</p> <p>Methods:</p> Name Description <code>__getitem__</code> <code>__len__</code> <code>draw</code> <p>Draw the specified diagrams into a large canvas. Returns an SVG string, which can be displayed e.g. in a</p> <code>query</code> <p>Query whether there is a diagram in the container, which would be selected by <code>selector</code>.</p>"},{"location":"reference/feyngraph/#feyngraph.DiagramContainer.__getitem__","title":"<code>__getitem__(index: int) -&gt; Diagram</code>","text":""},{"location":"reference/feyngraph/#feyngraph.DiagramContainer.__len__","title":"<code>__len__() -&gt; int</code>","text":""},{"location":"reference/feyngraph/#feyngraph.DiagramContainer.draw","title":"<code>draw(diagrams: list[int], n_cols: Optional[int] = 4)</code>","text":"<p>Draw the specified diagrams into a large canvas. Returns an SVG string, which can be displayed e.g. in a Jupyter notebook.</p> <p>Example: <pre><code>from from IPython.display import SVG\nfrom feyngraph import generate_diagrams\ndiags = generate_diagrams([\"u\", \"u~\"], [\"u\", \"u~\"], 0)\nSVG(topos.draw(range(len(diags))))\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>diagrams</code> <code>list[int]</code> <p>list of IDs of diagrams to draw</p> required <code>n_cols</code> <code>Optional[int]</code> <p>number of topologies to draw in each row</p> <code>4</code>"},{"location":"reference/feyngraph/#feyngraph.DiagramContainer.query","title":"<code>query(selector: DiagramSelector) -&gt; None | int</code>","text":"<p>Query whether there is a diagram in the container, which would be selected by <code>selector</code>.</p> <p>Returns:</p> Type Description <code>None | int</code> <p>None if no diagram is selected, the position of the first selected diagram otherwise</p>"},{"location":"reference/feyngraph/#feyngraph.DiagramGenerator","title":"<code>DiagramGenerator</code>","text":"<p>The main class used to generate Feynman diagrams.</p> <p>Examples:</p> <pre><code>model = Model.from_ufo(\"tests/Standard_Model_UFO\")\nselector = DiagramSelector()\nselector.set_opi_components(1)\ndiags = DiagramGenerator([\"g\", \"g\"], [\"u\", \"u__tilde__\", \"g\"], 1, model, selector).generate()\nassert(len(diags), 51)\n</code></pre> <p>Methods:</p> Name Description <code>__new__</code> <p>Create a new Diagram generator for the given process</p> <code>assign_topologies</code> <p>Assign particles and interactions to the given topologies.</p> <code>assign_topology</code> <p>Assign particles and interactions to the given topology.</p> <code>count</code> <p>Generate the diagrams of the given process without keeping them, only retaining the total number of found</p> <code>generate</code> <p>Generate the diagrams of the given process</p> <code>set_momentum_labels</code> <p>Set the names of the momenta. The first <code>n_external</code> ones are the external momenta, the remaining ones are</p>"},{"location":"reference/feyngraph/#feyngraph.DiagramGenerator.__new__","title":"<code>__new__(incoming: list[str], outgoing: list[str], n_loops: int, model: Model, selector: DiagramSelector | None = None) -&gt; DiagramGenerator</code>","text":"<p>Create a new Diagram generator for the given process</p>"},{"location":"reference/feyngraph/#feyngraph.DiagramGenerator.assign_topologies","title":"<code>assign_topologies(topos: list[Topology]) -&gt; DiagramContainer</code>","text":"<p>Assign particles and interactions to the given topologies.</p>"},{"location":"reference/feyngraph/#feyngraph.DiagramGenerator.assign_topology","title":"<code>assign_topology(topo: Topology) -&gt; DiagramContainer</code>","text":"<p>Assign particles and interactions to the given topology.</p>"},{"location":"reference/feyngraph/#feyngraph.DiagramGenerator.count","title":"<code>count() -&gt; int</code>","text":"<p>Generate the diagrams of the given process without keeping them, only retaining the total number of found diagrams.</p>"},{"location":"reference/feyngraph/#feyngraph.DiagramGenerator.generate","title":"<code>generate() -&gt; DiagramContainer</code>","text":"<p>Generate the diagrams of the given process</p>"},{"location":"reference/feyngraph/#feyngraph.DiagramGenerator.set_momentum_labels","title":"<code>set_momentum_labels(labels: list[str])</code>","text":"<p>Set the names of the momenta. The first <code>n_external</code> ones are the external momenta, the remaining ones are the loop momenta. Returns an error if the number of labels does not match the diagram.</p>"},{"location":"reference/feyngraph/#feyngraph.DiagramSelector","title":"<code>DiagramSelector</code>","text":"<p>A selector class which determines whether a diagram is to be kept or to be discarded. Multiple criteria can be specified. The available criteria are</p> <ul> <li>opi components: select only diagrams for which the number of one-particle-irreducible components matches any of the given counts</li> <li>custom functions: select only diagrams for which any of the given custom functions return <code>true</code></li> <li>self loops: select only diagrams which contain the specified number of self-loops</li> <li>on-shell: select only diagrams with on-shell external legs</li> <li>coupling powers: select only diagrams of the given power in the given coupling</li> <li>propagator count: select only diagrams with the specified number of propagators of the given field</li> <li>vertex count: select only diagrams with the specified number of vertices with the given fields</li> </ul> <p>For more precise definitions of each criterion, see the respective function.</p> <p>Examples: <pre><code>selector = DiagramSelector()\nselector.select_on_shell()\nselector.select_self_loops(0)\nselector.add_coupling_power(\"QCD\", 2)\nselector.add_coupling_power(\"QED\", 0)\nselector.add_propagator_count(\"t\", 0)\n</code></pre></p> <p>Methods:</p> Name Description <code>add_custom_function</code> <p>Add a constraint to only select diagrams for which the given function returns <code>true</code>. The function receives</p> <code>add_topology_function</code> <p>Add a custom topology selection function, which is used when the <code>DiagramSelector</code> is converted to a</p> <code>select_coupling_power</code> <p>Add a constraint to only select diagrams for which the power of <code>coupling</code> sums to <code>power</code>.</p> <code>select_on_shell</code> <p>Add a constraint to only select on-shell diagrams. On-shell diagrams are defined as diagrams with no self-energy</p> <code>select_opi_components</code> <p>Add a constraint to only select diagrams with <code>opi_count</code> one-particle-irreducible components.</p> <code>select_propagator_count</code> <p>Add a constraint to only select diagrams which contain exactly <code>count</code> propagators of the field <code>particle</code>.</p> <code>select_self_loops</code> <p>Add a constraint to only select diagrams with <code>count</code> self-loops. A self-loop is defined as an edge which ends</p> <code>select_vertex_count</code> <p>Add a constraint to only select diagrams which contain exactly <code>count</code> vertices of the fields <code>particles</code>.</p> <code>select_vertex_degree</code> <p>Add a criterion to only keep diagrams which contains <code>count</code> vertices of degree <code>degree</code>.</p>"},{"location":"reference/feyngraph/#feyngraph.DiagramSelector.add_custom_function","title":"<code>add_custom_function(py_function: Callable[[Diagram], bool])</code>","text":"<p>Add a constraint to only select diagrams for which the given function returns <code>true</code>. The function receives a single diagrams as input and should return a boolean.</p> <p>Examples: <pre><code>def s_channel(diag: feyngraph.Diagram) -&gt; bool:\n    n_momenta = len(diag.propagators()[0].momentum()) # Total number of momenta in the process\n    s_momentum = [1, 1]+ [0]*(n_momenta-2) # e.g. = [1, 1, 0, 0] for n_momenta = 4\n    return any(propagator.momentum() == s_momentum for propagator in diag.propagators())\n\nselector = feyngraph.DiagramSelector()\nselector.add_custom_function(s_channel)\n</code></pre></p>"},{"location":"reference/feyngraph/#feyngraph.DiagramSelector.add_topology_function","title":"<code>add_topology_function(py_function: Callable[[Topology], bool])</code>","text":"<p>Add a custom topology selection function, which is used when the <code>DiagramSelector</code> is converted to a <code>TopologySelector</code>, e.g. when a <code>DiagramGenerator</code> automatically generates topologies.</p>"},{"location":"reference/feyngraph/#feyngraph.DiagramSelector.select_coupling_power","title":"<code>select_coupling_power(coupling: str, power: int)</code>","text":"<p>Add a constraint to only select diagrams for which the power of <code>coupling</code> sums to <code>power</code>.</p>"},{"location":"reference/feyngraph/#feyngraph.DiagramSelector.select_on_shell","title":"<code>select_on_shell()</code>","text":"<p>Add a constraint to only select on-shell diagrams. On-shell diagrams are defined as diagrams with no self-energy insertions on external legs. This implementation considers internal edges carrying a single external momentum and no loop momentum, which is equivalent to a self-energy insertion on an external propagator.</p>"},{"location":"reference/feyngraph/#feyngraph.DiagramSelector.select_opi_components","title":"<code>select_opi_components(opi_count: int)</code>","text":"<p>Add a constraint to only select diagrams with <code>opi_count</code> one-particle-irreducible components.</p>"},{"location":"reference/feyngraph/#feyngraph.DiagramSelector.select_propagator_count","title":"<code>select_propagator_count(particle: str, count: int)</code>","text":"<p>Add a constraint to only select diagrams which contain exactly <code>count</code> propagators of the field <code>particle</code>.</p>"},{"location":"reference/feyngraph/#feyngraph.DiagramSelector.select_self_loops","title":"<code>select_self_loops(count: int)</code>","text":"<p>Add a constraint to only select diagrams with <code>count</code> self-loops. A self-loop is defined as an edge which ends on the same node it started on.</p>"},{"location":"reference/feyngraph/#feyngraph.DiagramSelector.select_vertex_count","title":"<code>select_vertex_count(particles: list[str], count: int)</code>","text":"<p>Add a constraint to only select diagrams which contain exactly <code>count</code> vertices of the fields <code>particles</code>.</p>"},{"location":"reference/feyngraph/#feyngraph.DiagramSelector.select_vertex_degree","title":"<code>select_vertex_degree(degree: int, count: int)</code>","text":"<p>Add a criterion to only keep diagrams which contains <code>count</code> vertices of degree <code>degree</code>.</p>"},{"location":"reference/feyngraph/#feyngraph.InteractionVertex","title":"<code>InteractionVertex</code>","text":"<p>Internal representaion of an interaction vertex.</p> <p>Methods:</p> Name Description <code>coupling_orders</code> <p>Get a list of coupling orders of the interaction.</p> <code>name</code> <p>Get the name of the interaction vertex.</p>"},{"location":"reference/feyngraph/#feyngraph.InteractionVertex.coupling_orders","title":"<code>coupling_orders()</code>","text":"<p>Get a list of coupling orders of the interaction.</p>"},{"location":"reference/feyngraph/#feyngraph.InteractionVertex.name","title":"<code>name()</code>","text":"<p>Get the name of the interaction vertex.</p>"},{"location":"reference/feyngraph/#feyngraph.Leg","title":"<code>Leg</code>","text":"<p>The class representing an external leg.</p> <p>Methods:</p> Name Description <code>id</code> <p>Get the leg's internal id</p> <code>momentum</code> <p>Get the internal representation of the propagator's momentum. The function returns a list of integers, where</p> <code>momentum_str</code> <p>Get the string-formatted momentum flowing through the propagator.</p> <code>particle</code> <p>Get the particle assigned to this leg.</p> <code>ray_index</code> <p>Get the external leg's ray index, i.e. the index of the leg of the vertex to which the external leg is</p> <code>vertex</code> <p>Get the vertex this leg is attached to. This function accepts an addition <code>_index</code> parameter to make its</p>"},{"location":"reference/feyngraph/#feyngraph.Leg.id","title":"<code>id() -&gt; int</code>","text":"<p>Get the leg's internal id</p>"},{"location":"reference/feyngraph/#feyngraph.Leg.momentum","title":"<code>momentum() -&gt; list[int]</code>","text":"<p>Get the internal representation of the propagator's momentum. The function returns a list of integers, where the <code>i</code>-th entry is the coefficient of the <code>i</code>-th momentum. The first <code>n_ext</code> momenta are external, the remaining momenta are the <code>n_loops</code> loop momenta.</p>"},{"location":"reference/feyngraph/#feyngraph.Leg.momentum_str","title":"<code>momentum_str() -&gt; str</code>","text":"<p>Get the string-formatted momentum flowing through the propagator.</p>"},{"location":"reference/feyngraph/#feyngraph.Leg.particle","title":"<code>particle() -&gt; Particle</code>","text":"<p>Get the particle assigned to this leg.</p>"},{"location":"reference/feyngraph/#feyngraph.Leg.ray_index","title":"<code>ray_index(_vertex: int = 0) -&gt; int</code>","text":"<p>Get the external leg's ray index, i.e. the index of the leg of the vertex to which the external leg is connected to (from the vertex perspective). This function accepts an addition <code>_vertex</code> parameter to make its signature identical to <code>Propagator.ray_index</code>, but the parameter is always ignored.</p>"},{"location":"reference/feyngraph/#feyngraph.Leg.vertex","title":"<code>vertex(_index: int = 0) -&gt; Vertex</code>","text":"<p>Get the vertex this leg is attached to. This function accepts an addition <code>_index</code> parameter to make its signature identical to <code>Propagator.index</code>, but the parameter is always ignored.</p>"},{"location":"reference/feyngraph/#feyngraph.Model","title":"<code>Model</code>","text":"<p>Internal representation of a model in FeynGraph.</p> <p>Methods:</p> Name Description <code>__new__</code> <p>Construct the default mode, the Standard Model in Feynman gauge.</p> <code>as_topology_model</code> <p>Return the topology model dervied from the model.</p> <code>from_qgraf</code> <p>Import a model in QGRAF's model format. The parser is not exhaustive in the options QGRAF supports and is only</p> <code>from_ufo</code> <p>Import a model in the UFO format. The path should specify the folder containing the model's <code>.py</code> files.</p> <code>particles</code> <p>Return the list of particles contained in the model.</p> <code>vertices</code> <p>Return the list of vertices contained in the model.</p>"},{"location":"reference/feyngraph/#feyngraph.Model.__new__","title":"<code>__new__() -&gt; Model</code>","text":"<p>Construct the default mode, the Standard Model in Feynman gauge.</p>"},{"location":"reference/feyngraph/#feyngraph.Model.as_topology_model","title":"<code>as_topology_model() -&gt; TopologyModel</code>","text":"<p>Return the topology model dervied from the model.</p>"},{"location":"reference/feyngraph/#feyngraph.Model.from_qgraf","title":"<code>from_qgraf(path: str) -&gt; Model</code>  <code>staticmethod</code>","text":"<p>Import a model in QGRAF's model format. The parser is not exhaustive in the options QGRAF supports and is only intended for backwards compatibility, especially for the models included in GoSam. UFO models should be preferred whenever possible.</p>"},{"location":"reference/feyngraph/#feyngraph.Model.from_ufo","title":"<code>from_ufo(path: str) -&gt; Model</code>  <code>staticmethod</code>","text":"<p>Import a model in the UFO format. The path should specify the folder containing the model's <code>.py</code> files.</p>"},{"location":"reference/feyngraph/#feyngraph.Model.particles","title":"<code>particles() -&gt; list[Particle]</code>","text":"<p>Return the list of particles contained in the model.</p>"},{"location":"reference/feyngraph/#feyngraph.Model.vertices","title":"<code>vertices() -&gt; list[InteractionVertex]</code>","text":"<p>Return the list of vertices contained in the model.</p>"},{"location":"reference/feyngraph/#feyngraph.Particle","title":"<code>Particle</code>","text":"<p>Internal representation of a particle in FeynGraph.</p> <p>Methods:</p> Name Description <code>anti_name</code> <p>Get the name of the particle's anti particle</p> <code>is_anti</code> <p>Return true, if the particle is an anti particle (PDG ID &lt; 0)</p> <code>is_fermi</code> <p>Return true if the particle obeys Fermi-Dirac statistics</p> <code>name</code> <p>Get the particle's name</p> <code>pdg</code> <p>Get the particle's PDG ID</p>"},{"location":"reference/feyngraph/#feyngraph.Particle.anti_name","title":"<code>anti_name() -&gt; str</code>","text":"<p>Get the name of the particle's anti particle</p>"},{"location":"reference/feyngraph/#feyngraph.Particle.is_anti","title":"<code>is_anti() -&gt; bool</code>","text":"<p>Return true, if the particle is an anti particle (PDG ID &lt; 0)</p>"},{"location":"reference/feyngraph/#feyngraph.Particle.is_fermi","title":"<code>is_fermi() -&gt; bool</code>","text":"<p>Return true if the particle obeys Fermi-Dirac statistics</p>"},{"location":"reference/feyngraph/#feyngraph.Particle.name","title":"<code>name() -&gt; str</code>","text":"<p>Get the particle's name</p>"},{"location":"reference/feyngraph/#feyngraph.Particle.pdg","title":"<code>pdg() -&gt; int</code>","text":"<p>Get the particle's PDG ID</p>"},{"location":"reference/feyngraph/#feyngraph.Propagator","title":"<code>Propagator</code>","text":"<p>The class representing an internal propagator.</p> <p>Methods:</p> Name Description <code>id</code> <p>Get the propagagtors internal id</p> <code>momentum</code> <p>Get the internal representation of the propagator's momentum. The function returns a list of integers, where</p> <code>momentum_str</code> <p>Get the string-formatted momentum flowing through the propagator.</p> <code>particle</code> <p>Get the particle assigned to the propagator.</p> <code>ray_index</code> <p>Get the propagators ray index with respect to the <code>index</code>-th vertex it is connected to, i.e. the index of the</p> <code>vertex</code> <p>Get the <code>index</code>-th vertex the propagator is connected to.</p> <code>vertices</code> <p>Get a list of vertices the propagator is connected to.</p>"},{"location":"reference/feyngraph/#feyngraph.Propagator.id","title":"<code>id() -&gt; int</code>","text":"<p>Get the propagagtors internal id</p>"},{"location":"reference/feyngraph/#feyngraph.Propagator.momentum","title":"<code>momentum() -&gt; list[int]</code>","text":"<p>Get the internal representation of the propagator's momentum. The function returns a list of integers, where the <code>i</code>-th entry is the coefficient of the <code>i</code>-th momentum. The first <code>n_ext</code> momenta are external, the remaining momenta are the <code>n_loops</code> loop momenta.</p>"},{"location":"reference/feyngraph/#feyngraph.Propagator.momentum_str","title":"<code>momentum_str() -&gt; str</code>","text":"<p>Get the string-formatted momentum flowing through the propagator.</p>"},{"location":"reference/feyngraph/#feyngraph.Propagator.particle","title":"<code>particle() -&gt; Particle</code>","text":"<p>Get the particle assigned to the propagator.</p>"},{"location":"reference/feyngraph/#feyngraph.Propagator.ray_index","title":"<code>ray_index(index: int) -&gt; int</code>","text":"<p>Get the propagators ray index with respect to the <code>index</code>-th vertex it is connected to, i.e. the index of the leg of the <code>index</code>-th vertex to which the propagator is connected to.</p>"},{"location":"reference/feyngraph/#feyngraph.Propagator.vertex","title":"<code>vertex(index: int) -&gt; Vertex</code>","text":"<p>Get the <code>index</code>-th vertex the propagator is connected to.</p>"},{"location":"reference/feyngraph/#feyngraph.Propagator.vertices","title":"<code>vertices() -&gt; list[Vertex]</code>","text":"<p>Get a list of vertices the propagator is connected to.</p>"},{"location":"reference/feyngraph/#feyngraph.Topology","title":"<code>Topology</code>","text":"<p>The internal representation of a topology graph.</p> <p>Methods:</p> Name Description <code>draw_tikz</code> <p>Draw the topology in the TikZ format</p> <code>edges</code> <p>Get a list of all nodes in the topology.</p> <code>nodes</code> <p>Get a list of all edges in the topology.</p> <code>symmetry_factor</code> <p>Get the topology's symmetry factor</p>"},{"location":"reference/feyngraph/#feyngraph.Topology.draw_tikz","title":"<code>draw_tikz(path: str)</code>","text":"<p>Draw the topology in the TikZ format</p>"},{"location":"reference/feyngraph/#feyngraph.Topology.edges","title":"<code>edges() -&gt; list[Edge]</code>","text":"<p>Get a list of all nodes in the topology.</p>"},{"location":"reference/feyngraph/#feyngraph.Topology.nodes","title":"<code>nodes() -&gt; list[Node]</code>","text":"<p>Get a list of all edges in the topology.</p>"},{"location":"reference/feyngraph/#feyngraph.Topology.symmetry_factor","title":"<code>symmetry_factor() -&gt; int</code>","text":"<p>Get the topology's symmetry factor</p>"},{"location":"reference/feyngraph/#feyngraph.TopologyModel","title":"<code>TopologyModel</code>","text":"<p>A model containing only topological information, i.e. the allowed degrees of nodes.</p> <p>Methods:</p> Name Description <code>__new__</code> <p>Create a new topology model containing nodes with degrees specified in <code>node_degrees</code>.</p>"},{"location":"reference/feyngraph/#feyngraph.TopologyModel.__new__","title":"<code>__new__(node_degrees: list[int]) -&gt; TopologyModel</code>","text":"<p>Create a new topology model containing nodes with degrees specified in <code>node_degrees</code>.</p>"},{"location":"reference/feyngraph/#feyngraph.Vertex","title":"<code>Vertex</code>","text":"<p>The class representing an internal vertex.</p> <p>Methods:</p> Name Description <code>degree</code> <p>Get the vertex' degree</p> <code>id</code> <p>Get the vertex' internal id</p> <code>interaction</code> <p>Get the interaction assigned to the vertex.</p> <code>match_particles</code> <p>Check whether the given particle names match the interaction of the vertex.</p> <code>particles_ordered</code> <p>Get the particles flowing into this vertex ordered such, that the sequence of particles matches the</p> <code>propagators</code> <p>Get the propagators connected to this vertex. If one of the propagators is a self-loop, it will only</p> <code>propagators_ordered</code> <p>Get the propagators connected to this vertex ordered such, that the sequence of particles matches the</p>"},{"location":"reference/feyngraph/#feyngraph.Vertex.degree","title":"<code>degree() -&gt; int</code>","text":"<p>Get the vertex' degree</p>"},{"location":"reference/feyngraph/#feyngraph.Vertex.id","title":"<code>id() -&gt; int</code>","text":"<p>Get the vertex' internal id</p>"},{"location":"reference/feyngraph/#feyngraph.Vertex.interaction","title":"<code>interaction() -&gt; InteractionVertex</code>","text":"<p>Get the interaction assigned to the vertex.</p>"},{"location":"reference/feyngraph/#feyngraph.Vertex.match_particles","title":"<code>match_particles() -&gt; bool</code>","text":"<p>Check whether the given particle names match the interaction of the vertex.</p>"},{"location":"reference/feyngraph/#feyngraph.Vertex.particles_ordered","title":"<code>particles_ordered() -&gt; list[Particle]</code>","text":"<p>Get the particles flowing into this vertex ordered such, that the sequence of particles matches the definition of the interaction in the model.</p>"},{"location":"reference/feyngraph/#feyngraph.Vertex.propagators","title":"<code>propagators() -&gt; list[Leg | Propagator]</code>","text":"<p>Get the propagators connected to this vertex. If one of the propagators is a self-loop, it will only appear once in the list of propagators!</p>"},{"location":"reference/feyngraph/#feyngraph.Vertex.propagators_ordered","title":"<code>propagators_ordered() -&gt; list[Leg | Propagator]</code>","text":"<p>Get the propagators connected to this vertex ordered such, that the sequence of particles matches the definition of the interaction in the model. If one of the propagators is a self-loop, it will only appear once in the list of propagators!</p>"},{"location":"reference/feyngraph/#feyngraph.generate_diagrams","title":"<code>generate_diagrams(particles_in: list[str], particles_out: list[str], n_loops: int, model: Optional[Model] = None, selector: Optional[DiagramSelector] = None) -&gt; DiagramContainer</code>","text":"<p>Convenience function for diagram generation. This function only requires the minimal set of input information, the incoming particles and the outgoing particles. Sensible defaults are provided for all other variables.</p> <p>Examples: <pre><code>import feyngraph as fg\ndiagrams = fg.generate_diagrams([\"u\", \"u__tilde__\"], [\"u\", \"u__tilde\"], 2)\nassert(len(diagrams), 4632)\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>particles_in</code> <code>list[str]</code> <p>list of incoming particles, specified by name</p> required <code>particles_out</code> <code>list[str]</code> <p>list of outgoing particles, specified by name</p> required <code>n_loops</code> <code>int</code> <p>number of loops in the generated diagrams [default: 0]</p> required <code>model</code> <code>Optional[Model]</code> <p>model used in diagram generation [default: SM in Feynman gauge]</p> <code>None</code> <code>selector</code> <code>Optional[DiagramSelector]</code> <p>selector struct determining which diagrams are to be kept [default: all diagrams for zero loops, only one-particle-irreducible diagrams for loop-diagrams]</p> <code>None</code>"},{"location":"reference/feyngraph/#feyngraph.set_threads","title":"<code>set_threads(n_threads: int)</code>","text":"<p>Set the number of threads FeynGraph will use. The default is the maximum number of available threads.</p> <p>Parameters:</p> Name Type Description Default <code>n_threads</code> <code>int</code> <p>Number of threads to use (shared across all instanced of FeynGraph running for the current process)</p> required"},{"location":"reference/topology/","title":"API Reference Topology","text":"<p>Classes:</p> Name Description <code>Edge</code> <p>The internal representaion of a graph edge.</p> <code>Node</code> <p>The internal representation of a graph node.</p> <code>Topology</code> <p>The internal representation of a topology graph.</p> <code>TopologyContainer</code> <p>The class representing a list of topologies.</p> <code>TopologyGenerator</code> <p>The main generator class of the topology module.</p> <code>TopologyModel</code> <p>A model containing only topological information, i.e. the allowed degrees of nodes.</p> <code>TopologySelector</code> <p>A selector class which determines whether a topology is to be kept or to be discarded. The available critera are</p>"},{"location":"reference/topology/#feyngraph.topology.Edge","title":"<code>Edge</code>","text":"<p>The internal representaion of a graph edge.</p> <p>Methods:</p> Name Description <code>momentum</code> <p>Get the internal representation of the edge's momentum. The function returns a list of integers, where</p> <code>nodes</code> <p>Get a list of the ids of the connected nodes.</p>"},{"location":"reference/topology/#feyngraph.topology.Edge.momentum","title":"<code>momentum() -&gt; list[int]</code>","text":"<p>Get the internal representation of the edge's momentum. The function returns a list of integers, where the <code>i</code>-th entry is the coefficient of the <code>i</code>-th momentum. The first <code>n_ext</code> momenta are external, the remaining momenta are the <code>n_loops</code> loop momenta.</p>"},{"location":"reference/topology/#feyngraph.topology.Edge.nodes","title":"<code>nodes() -&gt; list[int]</code>","text":"<p>Get a list of the ids of the connected nodes.</p>"},{"location":"reference/topology/#feyngraph.topology.Node","title":"<code>Node</code>","text":"<p>The internal representation of a graph node.</p> <p>Methods:</p> Name Description <code>adjacent</code> <p>Get a list of the ids of the adjacent nodes.</p> <code>degree</code> <p>Get the degree of the node.</p>"},{"location":"reference/topology/#feyngraph.topology.Node.adjacent","title":"<code>adjacent() -&gt; list[int]</code>","text":"<p>Get a list of the ids of the adjacent nodes.</p>"},{"location":"reference/topology/#feyngraph.topology.Node.degree","title":"<code>degree() -&gt; int</code>","text":"<p>Get the degree of the node.</p>"},{"location":"reference/topology/#feyngraph.topology.Topology","title":"<code>Topology</code>","text":"<p>The internal representation of a topology graph.</p> <p>Methods:</p> Name Description <code>draw_tikz</code> <p>Draw the topology in the TikZ format</p> <code>edges</code> <p>Get a list of all nodes in the topology.</p> <code>nodes</code> <p>Get a list of all edges in the topology.</p> <code>symmetry_factor</code> <p>Get the topology's symmetry factor</p>"},{"location":"reference/topology/#feyngraph.topology.Topology.draw_tikz","title":"<code>draw_tikz(path: str)</code>","text":"<p>Draw the topology in the TikZ format</p>"},{"location":"reference/topology/#feyngraph.topology.Topology.edges","title":"<code>edges() -&gt; list[Edge]</code>","text":"<p>Get a list of all nodes in the topology.</p>"},{"location":"reference/topology/#feyngraph.topology.Topology.nodes","title":"<code>nodes() -&gt; list[Node]</code>","text":"<p>Get a list of all edges in the topology.</p>"},{"location":"reference/topology/#feyngraph.topology.Topology.symmetry_factor","title":"<code>symmetry_factor() -&gt; int</code>","text":"<p>Get the topology's symmetry factor</p>"},{"location":"reference/topology/#feyngraph.topology.TopologyContainer","title":"<code>TopologyContainer</code>","text":"<p>The class representing a list of topologies.</p> <p>Methods:</p> Name Description <code>__getitem__</code> <code>__len__</code> <code>draw</code> <p>Draw the specified topologies into a large canvas. Returns an SVG string, which can be displayed e.g. in a</p> <code>query</code> <p>Query whether there is a topology in the container, which would be selected by <code>selector</code>.</p>"},{"location":"reference/topology/#feyngraph.topology.TopologyContainer.__getitem__","title":"<code>__getitem__(index: int) -&gt; Topology</code>","text":""},{"location":"reference/topology/#feyngraph.topology.TopologyContainer.__len__","title":"<code>__len__() -&gt; int</code>","text":""},{"location":"reference/topology/#feyngraph.topology.TopologyContainer.draw","title":"<code>draw(topologies: list[int], n_cols: Optional[int] = 4) -&gt; str</code>","text":"<p>Draw the specified topologies into a large canvas. Returns an SVG string, which can be displayed e.g. in a Jupyter notebook.</p> <p>Example: <pre><code>from from IPython.display import SVG\nfrom feyngraph.topology import TopologyGenerator, TopologyModel\ntopos = TopologyGenerator(4, 0, TopologyModel([3, 4]))\nSVG(topos.draw(range(len(topos))))\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>topologies</code> <code>list[int]</code> <p>list of IDs of topologies to draw</p> required <code>n_cols</code> <code>Optional[int]</code> <p>number of topologies to draw in each row</p> <code>4</code>"},{"location":"reference/topology/#feyngraph.topology.TopologyContainer.query","title":"<code>query(selector: TopologySelector)</code>","text":"<p>Query whether there is a topology in the container, which would be selected by <code>selector</code>.</p>"},{"location":"reference/topology/#feyngraph.topology.TopologyGenerator","title":"<code>TopologyGenerator</code>","text":"<p>The main generator class of the topology module.</p> <p>Examples: <pre><code>model = TopologyModel([3, 4])\nselector = TopologySelector()\nselector.select_opi_components(1)\ngenerator = TopologyGenerator(4, 3, model, selector)\ntopologies = generator.generate()\nassert(len(topologies), 6166)\n</code></pre></p> <p>Methods:</p> Name Description <code>__new__</code> <p>Create a new topology generator.</p> <code>count</code> <p>Generate the topologies for the given configuration without saving them, only returning the total number.</p> <code>generate</code> <p>Generate the topologies for the given configuration.</p>"},{"location":"reference/topology/#feyngraph.topology.TopologyGenerator.__new__","title":"<code>__new__(n_external: int, n_loops: int, model: TopologyModel, selector: Optional[TopologySelector] = None) -&gt; TopologyGenerator</code>","text":"<p>Create a new topology generator.</p> <p>Parameters:</p> Name Type Description Default <code>selector</code> <code>Optional[TopologySelector]</code> <p>the selector choosing whether a given topology is kept or discarded. If no selector is specified, all topologies are kept</p> <code>None</code>"},{"location":"reference/topology/#feyngraph.topology.TopologyGenerator.count","title":"<code>count() -&gt; int</code>","text":"<p>Generate the topologies for the given configuration without saving them, only returning the total number.</p>"},{"location":"reference/topology/#feyngraph.topology.TopologyGenerator.generate","title":"<code>generate() -&gt; TopologyContainer</code>","text":"<p>Generate the topologies for the given configuration.</p>"},{"location":"reference/topology/#feyngraph.topology.TopologyModel","title":"<code>TopologyModel</code>","text":"<p>A model containing only topological information, i.e. the allowed degrees of nodes.</p> <p>Methods:</p> Name Description <code>__new__</code> <p>Create a new topology model containing nodes with degrees specified in <code>node_degrees</code>.</p>"},{"location":"reference/topology/#feyngraph.topology.TopologyModel.__new__","title":"<code>__new__(node_degrees: list[int]) -&gt; TopologyModel</code>","text":"<p>Create a new topology model containing nodes with degrees specified in <code>node_degrees</code>.</p>"},{"location":"reference/topology/#feyngraph.topology.TopologySelector","title":"<code>TopologySelector</code>","text":"<p>A selector class which determines whether a topology is to be kept or to be discarded. The available critera are</p> <ul> <li>node degrees: select only topologies for which the number of nodes with a specified degree matches any of the given counts</li> <li>node partition: select only topologies matching any of the given node partitions, i.e. a topology for which the number of nodes of each degree exactly matches the count specified in the partition.</li> <li>opi components: select only topologies for which the number of one-particle-irreducible components matches any of the given counts</li> <li>custom functions: select only topologies for which any of the given custom functions return <code>true</code></li> </ul> <p>Methods:</p> Name Description <code>add_custom_function</code> <p>Add a constraint to only select topologies for which the given function returns <code>true</code>. The function receives</p> <code>clear</code> <p>Clear all criteria.</p> <code>select_node_degree</code> <p>Add a constraint to only select topologies which contain <code>selection</code> nodes of degree <code>degree</code>.</p> <code>select_node_degree_range</code> <p>Add a constraint to only select topologies which contain between <code>start</code> and <code>end</code> nodes of degree <code>degree</code>.</p> <code>select_node_partition</code> <p>Add a constraint to only select topologies for which the number of nodes of all given degree exactly matches</p> <code>select_on_shell</code> <p>Select only topologies with no self-energy insertions on external legs. This implementation considers internal</p> <code>select_opi_components</code> <p>Add a constraints to only select topologies with <code>opi_count</code> one-particle-irreducible components.</p> <code>select_self_loops</code> <p>Select only topologies containing exactly <code>n</code> self-loops.</p>"},{"location":"reference/topology/#feyngraph.topology.TopologySelector.add_custom_function","title":"<code>add_custom_function(py_function: Callable[[Topology], bool])</code>","text":"<p>Add a constraint to only select topologies for which the given function returns <code>true</code>. The function receives a single topology as input and should return a boolean.</p> <p>Examples: <pre><code>def no_self_loop(topo: feyngraph.topology.Topology) -&gt; bool:\n    return any(edge.get_nodes()[0] == edge.get_nodes()[1] for edge in topo.get_edges())\n\nselector = feyngraph.topology.TopologySelector()\nselector.add_custom_function(no_self_loop)\n</code></pre></p>"},{"location":"reference/topology/#feyngraph.topology.TopologySelector.clear","title":"<code>clear()</code>","text":"<p>Clear all criteria.</p>"},{"location":"reference/topology/#feyngraph.topology.TopologySelector.select_node_degree","title":"<code>select_node_degree(degree: int, selection: int)</code>","text":"<p>Add a constraint to only select topologies which contain <code>selection</code> nodes of degree <code>degree</code>.</p>"},{"location":"reference/topology/#feyngraph.topology.TopologySelector.select_node_degree_range","title":"<code>select_node_degree_range(degree: int, start: int, end: int)</code>","text":"<p>Add a constraint to only select topologies which contain between <code>start</code> and <code>end</code> nodes of degree <code>degree</code>.</p>"},{"location":"reference/topology/#feyngraph.topology.TopologySelector.select_node_partition","title":"<code>select_node_partition(partition: list[tuple[int, int]])</code>","text":"<p>Add a constraint to only select topologies for which the number of nodes of all given degree exactly matches he specified count.</p> <p>Examples: <pre><code>selector = TopologySelector()\n# Select only topologies containing exactly four nodes of degree 3 and one node of degree 4\nselector.select_node_partition([(3, 4), (4, 1)])\n</code></pre></p>"},{"location":"reference/topology/#feyngraph.topology.TopologySelector.select_on_shell","title":"<code>select_on_shell()</code>","text":"<p>Select only topologies with no self-energy insertions on external legs. This implementation considers internal edges carrying a single external momentum and no loop momentum, which is equivalent to a self-energy insertion on an external edge.</p>"},{"location":"reference/topology/#feyngraph.topology.TopologySelector.select_opi_components","title":"<code>select_opi_components(opi_count: int)</code>","text":"<p>Add a constraints to only select topologies with <code>opi_count</code> one-particle-irreducible components.</p>"},{"location":"reference/topology/#feyngraph.topology.TopologySelector.select_self_loops","title":"<code>select_self_loops(n: int)</code>","text":"<p>Select only topologies containing exactly <code>n</code> self-loops.</p>"},{"location":"usage/cli/","title":"Command Line Interface","text":"<p>For standalone usage, FeynGraph includes a command line utility called <code>feyngraph</code>. This utility is mostly intended for quick prototyping and backwards compatibility with older diagram generators, and is therefore kept relatively simple.</p>"},{"location":"usage/cli/#installation","title":"Installation","text":"<p>The <code>feyngraph</code> command line utility is automatically installed with the FeynGraph library, it requires some additional Python packages though. They are listed in the <code>cli</code> feature and can therefore be installed with <pre><code>pip install feyngraph[cli]\n</code></pre></p>"},{"location":"usage/cli/#basic-usage","title":"Basic Usage","text":"<p>The <code>feyngraph</code> CLI utility requires a configuration file (see Configuration Options) and generates a single output file from the given specification. The output is rendered through a Jinja2 Template, which can be either specified with the <code>--template</code> option or in the config file. The template receives a single object, the DiagramContainer <code>diags</code> containing all diagrams for the given specification. One template is included with FeynGraph, <code>json.jinja</code> to render the diagrams in JSON format. This is also the default output format if no template is given.</p>"},{"location":"usage/cli/#configuration-options","title":"Configuration Options","text":"<p><code>feyngraph</code> expects a single config file in TOML format. A full example configuration using all available options reads <pre><code>template = \"json.jinja\"\n\n[process]\nincoming = [\"u\", \"u~\"]\noutgoing = [\"g\", \"g\"]\nloops = 2\nmodel = \"models/Standard_Model_UFO\"\nmomenta = [\"p1\", \"p2\", \"k1\", \"k2\", \"l1\", \"l2\"]\n\n[filter]\nonshell = true\nself_loops = 0\nopi_components = 1\ncoupling_orders = { \"QCD\" = 2, \"EW\" = 0 }\ncustom_function = \"filter\"\ncustom_code = \"\"\"\ndef filter(d: fg.Diagram) -&gt; bool:\n    return any(\n        sum(p.id() &lt; d.n_ext() for p in v.propagators()) &gt;= 2 for v in d.vertices()\n    )\n\nreturn filter\n\"\"\"\n\n[drawing]\nformat = \"svg\"\noutdir = \"tmp\"\nfilename = \"d_{i}\"\n</code></pre> The only global option is <code>template</code>, which specifies the path to the Jinja template the output is rendered with. Note that this option is overwritten by the <code>--template</code> command line option if it is set.</p>"},{"location":"usage/cli/#process-specification","title":"Process Specification","text":"<p>The physical process is specified in the <code>[process]</code> table. The possible options are</p> <ul> <li><code>incoming</code>: List of incoming particles, specified as list of the particle names.</li> <li><code>outgoing</code>: List of outgoing particles, specified as list of the particle names.</li> <li><code>loops</code>: Number of loops in the generated diagrams.</li> <li><code>model</code>[optional]: Path to the requested model. Can be the folder of a UFO model or the file of a QGRAF model. Defaults to the Standard Model in Feynman gauge if not specified.</li> <li><code>momenta</code>[optional]: List of momentum labels to use in the output. Defaults to <code>p&lt;i&gt;</code> for external momenta and <code>l&lt;i&gt;</code> for loop momenta.</li> </ul>"},{"location":"usage/cli/#diagram-filters","title":"Diagram Filters","text":"<p>Several options are available to restrict the set of generated diagrams, they are specified in the <code>[filter]</code> table.</p> <ul> <li><code>onshell</code>: If <code>true</code>, keep only diagrams for which the external legs are on-shell. This is equivalent to removing all diagrams with an internal propagator carrying a single external momentum.</li> <li><code>self_loops</code>: Keep only diagrams with the specified number of self-loops, i.e. propagators starting and ending at the same vertex.</li> <li><code>coupling_orders</code>: Keep only diagrams with the given power in the respective coupling. Multiple couplings can be specified.</li> </ul> <p>Additionally, since the <code>feyngraph</code> utility is just a small wrapper around the FeynGraph Python interface, arbitrary filters are also possible. Arbitrary Python code can be passed with the <code>custom_code</code> property, the name of the custom filter function can then be set with the <code>custom_function</code> property. This is expected to be a function taking a single Diagram as input and returning a <code>bool</code> as output.</p> <p>Warning</p> <p>The custom filter option can run arbitrary code through the Python interpreter, so make sure to only use filters from trusted sources.</p>"},{"location":"usage/cli/#diagram-drawing","title":"Diagram Drawing","text":"<p>The generated diagrams can also be automatically drawn, this feature is active if the <code>[drawing]</code> table is included in the config. One output file is created for every diagram. The format can be chosen through the options</p> <ul> <li><code>format</code>: Format of the drawing output. Supported values are <code>svg</code> and <code>tikz</code>. The default is <code>svg</code>.</li> <li><code>outdir</code>: Directory to put the drawings in. Default is <code>feyngraph_drawings</code>.</li> <li><code>filename</code>: Filename template for the output files. The given string is processed with the <code>str.format()</code> method, which receives the single input <code>i</code>, the identifier of the diagram. The appropriate file ending is appended automatically.</li> </ul>"},{"location":"usage/library/","title":"Usage Overview","text":""},{"location":"usage/library/#convenience-functions","title":"Convenience Functions","text":"<p>For convenience when generating diagrams in the 'standard' setup, FeynGraph provides the <code>generate_diagrams</code> function. For example, the 2-loop diagrams for the process \\(u\\bar{u} \\rightarrow ggg\\) with the standard settings can be generated with</p>  Python Rust <pre><code>import feyngraph as fg\ndiags = fg.generate_diagrams([\"u\", \"u~\"], [\"g\"]*3, 2)\n</code></pre> <pre><code>use feyngraph::generate_diagrams;\nlet diags = generate_diagrams(&amp;[\"u\", \"u~\"], &amp;[\"g\"; 3], 2, Default::default(), Default::default());\n</code></pre> <p>By default, the used model is the Standard Model in Feynman gauge imported from the default FeynRules Standard Model and no diagram selection is performed.</p>"},{"location":"usage/library/#lower-level-interface","title":"Lower-level Interface","text":"<p>If more control is needed over the generation process than the convenience functions allow, the underlying generator objects can be used manually. The diagram generation process in FeynGraph is split into two steps,</p> <ol> <li>Generate all topologies possibly contributing to the process (handled by a TopologyGenerator)</li> <li>Assign all combinations of particles and vertices to the topologies (handled by a DiagramGenerator)</li> </ol> <p>Details on the respective steps are given on the following pages.</p>"},{"location":"usage/library/#global-library-configuration","title":"Global Library Configuration","text":"<p>FeynGraph has some global options to control the library's general environment.</p>"},{"location":"usage/library/#multithreading","title":"Multithreading","text":"<p>FeynGraph uses the <code>rayon</code> Rust crate to parallelize the diagram generation. By default, all available logical cores of the host system are used. If this is undesired, the number of used threads can be chosen manually:</p>  Python Rust <pre><code>import feyngraph as fg\nfg.set_threads(16)\n</code></pre> <p>FeynGraph uses <code>rayon</code>'s default global thread pool, which can be initialized to a specific number of threads with <pre><code>use rayon::ThreadPoolBuilder;\nThreadPoolBuilder::new().num_threads(16).build_global().unwrap();\n</code></pre> See the <code>rayon</code> documentation for more details.</p>"},{"location":"usage/library/#logging","title":"Logging","text":"Python Rust <p>FeynGraph uses Pythons standard <code>logging</code> interface. To see the logging messages, the logger has to be configured, e.g. with a <code>RichHandler</code> for nice formatting: <pre><code>import logging\nfrom rich.logging import RichHandler\nlogging.basicConfig(\n  format=\"%(message)s\",\n  datefmt=\"[%X]\",\n  handlers=[RichHandler(show_path=False, rich_tracebacks=True)],\n)\n</code></pre></p> <p>FeynGraph uses the <code>log</code> crate for logging. If FeynGraph is used in an executable, it should include a logger to consume and show the logs produced by FeynGraph.</p>"},{"location":"usage/library/diagrams/","title":"Generating Feynman Diagrams","text":"<p>Feynman diagrams can be generated in two ways in FeynGraph, by having a <code>DiagramGenerator</code> assigning particles and vertices to existing <code>Topology</code> objects or have the <code>DiagramGenerator</code> produce the diagrams directly. The second option is just a shorthand version of the first, where the <code>DiagramGenerator</code> handles the generation of the topologies internally.</p>"},{"location":"usage/library/diagrams/#models","title":"Models","text":"<p>At the Feynman diagram level, a full physical model is required. This is supplied via a <code>Model</code> object. FeynGraph supports fully automatic import of two commonly used model formats: UFO 2.0 models through the <code>from_ufo(...)</code> function and QGRAF models through the <code>from_qgraf(...)</code> function.</p> <p>Warning</p> <p>QGRAF models are supported primarily for backwards compatibility and do not support all features of FeynGraph. Most notably, FeynGraph reads the analytic structure of fermionic vertices from UFO models to correctly assign signs to diagrams containing four(or more)-fermion vertices. This information is not available in QGRAF models and therefore signs of diagrams containing such vertices might not be consistent when using a QGRAF model.</p> <p>The FeynGraph distribution contains only a single model, the Standard Model in Feynman gauge imported from the default FeynRules model at compile time.</p>"},{"location":"usage/library/diagrams/#diagram-filtering","title":"Diagram Filtering","text":"<p>FeynGraph generates all diagrams with a given set of incoming/outgoing external legs at the given loop order. Often only a subset of these diagrams is desired though, e.g. only diagrams with a specific power in a coupling. Constraints like these can be enforced through a <code>DiagramSelector</code> object. Only diagrams selected by the selector are kept, all others are discarded. The <code>DiagramSelector</code> provides some predefined selection criteria for common requirements, see the reference for a list. If these criteria are insufficient for a given requirement, the <code>DiagramSelector</code> provides the <code>add_custom_function</code> method to add a custom function to the selector. Only diagrams for which this function returns <code>True</code> are kept. The same criterion can be added multiple times with different values, the <code>DiagramSelector</code> will then select diagrams satisfying any of the given values. If several different criteria are given, the diagram is required to fulfill all of them.</p> <p>Tip</p> <p>When using the <code>DiagramGenerator</code>'s automatic topology generation, the given <code>DiagramSelector</code> is automatically converted to a <code>TopologySelector</code> and all topological selection criteria are already applied at topology level. This is not possible with custom functions, but the <code>DiagramSelector</code> provides a <code>add_topology_function</code> method to add custom functions applied at topology level through a <code>TopologySelector</code>. This can significantly improve performance for complicated processes with many topologies.</p> <p>Example</p> <p>Consider the virtual NLO QCD corrections to the electroweak production of a Higgs boson pair in the Standard Model, specifically \\(u\\bar{u} \\rightarrow HHu\\bar{u}\\). The Born process is at order \\(\\mathcal{O}(\\alpha^4)\\mathcal{O}(\\alpha_s^0)\\), the NLO QCD corrections at \\(\\mathcal{O}(\\alpha^4)\\mathcal{O}(\\alpha_s^2)\\). Additionally, some more common restrictions are applied:</p> <ul> <li>All external legs should be on-shell, i.e. there are no self-energy insertions on an external leg.</li> <li>Diagrams should not contain any self-loops.</li> <li>In the current set of diagrams, there are many diagrams containing a purely electroweak loop radiating the Higgs pair. These can be interpreted as EW corrections to a QCD process with two additionally radiated Higgs bosons. To remove these, we restrict the diagrams to contain a gluon in the loop.</li> </ul>  Python Rust <pre><code>import feyngraph as fg\n\ndef gluon_loop(d: fg.Diagram) -&gt; bool:\n  return any(\n    p.particle().name() == \"g\" for p in d.chord(0) # (1)!\n  )\n\ns = fg.DiagramSelector()\ns.select_on_shell()\ns.select_self_loops(0)\ns.add_coupling_power(\"QED\", 4)\ns.add_coupling_power(\"QCD\", 2)\ns.add_custom_function(gluon_loop)\n</code></pre> <ol> <li>Note that the <code>\"g\"</code> particle name is model specific.</li> </ol> <pre><code>use feyngraph::prelude::*;\n\nfn gluon_loop(d: DiagramView&lt;'_&gt;) -&gt; bool { // (1)!\n  return d.chord(0).any(|p: PropagatorView&lt;'_&gt;| p.particle().name() == \"g\"); // (2)!\n}\n\nlet mut s = DiagramSelector::new();\ns.select_on_shell();\ns.select_self_loops(0);\ns.add_coupling_power(\"QED\", 4);\ns.add_coupling_power(\"QCD\", 2);\ns.add_custom_function(Arc::new(gluon_loop));\n</code></pre> <ol> <li>Note the appearance of the View objects here: they provide the public interface of the underlying data objects, e.g. <code>DiagramView</code> provides the interface to the underlying <code>Diagram</code>.</li> <li>Note that the <code>\"g\"</code> particle name is model specific.</li> </ol>"},{"location":"usage/library/diagrams/#generating-feynman-diagrams_1","title":"Generating Feynman Diagrams","text":"<p>The final production of the Feynman diagrams is handled by the <code>DiagramGenerator</code>. The minimal set of information needed to generate Feynman diagrams is the set of incoming/outgoing external legs, the number of loops and a model.</p> <p>The <code>DiagramGenerator</code> supports two operating modes, the diagram generation mode an the topology assignment mode.</p>"},{"location":"usage/library/diagrams/#diagram-generation-mode","title":"Diagram Generation Mode","text":"<p>In diagram generation mode, the <code>DiagramGenerator</code>'s <code>generate()</code> function, the topologies contributing to the given process are generated automatically by the <code>DiagramGenerator</code>.</p> <p>Example</p>  Python Rust <pre><code>import feyngraph as fg\n\ndiags = fg.DiagramGenerator([\"u\", \"u~\"], [\"H\", \"H\", \"u\", \"u~\"], 1, fg.Model()).generate()\nassert(len(diags) == 15966)\n\ndef gluon_loop(d: fg.Diagram) -&gt; bool:\n  return any(\n    p.particle().name() == \"g\" for p in d.chord(0)\n  )\n\ns = fg.DiagramSelector()\ns.select_on_shell()\ns.select_self_loops(0)\ns.add_coupling_power(\"QED\", 4)\ns.add_coupling_power(\"QCD\", 2)\ns.add_custom_function(gluon_loop)\ndiags = fg.DiagramGenerator([\"u\", \"u~\"], [\"H\", \"H\", \"u\", \"u~\"], 1, fg.Model(), selector = s).generate()\nassert(len(diags) == 72)\n</code></pre> <pre><code>use feyngraph::prelude::*;\n\nlet diags = DiagramGenerator::new(&amp;[\"u\", \"u~\"], &amp;[\"H\", \"H\", \"u\", \"u~\"], 1, Model::default(), None).generate();\nassert_eq!(diags.len(), 15966);\n\nfn gluon_loop(d: DiagramView&lt;'_&gt;) -&gt; bool {\n  return d.chord(0).any(|p: PropagatorView&lt;'_&gt;| p.particle().name() == \"g\");\n}\n\nlet mut s = DiagramSelector::new();\ns.select_on_shell();\ns.select_self_loops(0);\ns.add_coupling_power(\"QED\", 4);\ns.add_coupling_power(\"QCD\", 2);\ns.add_custom_function(Arc::new(gluon_loop));\n\nlet diags = DiagramGenerator::new(&amp;[\"u\", \"u~\"], &amp;[\"H\", \"H\", \"u\", \"u~\"], 1, Model::default(), Some(s)).generate();\nassert_eq!(diags.len(), 72);\n</code></pre>"},{"location":"usage/library/diagrams/#assign-mode","title":"Assign Mode","text":"<p>If preprocessing on the topologies is necessary or only specific topologies are to be considered, the <code>DiagramGenerator</code> can produce Feynman diagrams from given <code>Topology</code> objects.</p> <p>Example</p>  Python Rust <pre><code>import feyngraph as fg\nfrom feyngraph.topology import TopologyGenerator\n\nsm = fg.Model()\ntopos = TopologyGenerator(6, 2, sm.as_topology_model()).generate()\ndiags = fg.DiagramGenerator([\"g\", \"g\"], [\"u\", \"u~\", \"g\", \"g\"], 2, sm).assign_topology(topos[1833])\nassert(len(diags) == 1)\n</code></pre> <pre><code>use feyngraph::{prelude::*, topology::TopologyGenerator};\n\nlet sm = Model::default();\nlet topos = TopologyGenerator::new(6, 2, (&amp;sm).into(), None).generate();\nlet diags = DiagramGenerator(&amp;[\"g\", \"g\"], &amp;[\"u\", \"u~\", \"g\", \"g\"], 2, sm, None).assign_topology(&amp;topos[1833]);\nassert_eq!(diags.len(), 1);\n</code></pre> <p>Tip</p> <p>Assigning topologies with the <code>generate()</code> and <code>assign_topologies(...)</code> topologies runs fully in parallel in the Rust backend. Calling <code>assign_topology(...)</code> multiple times on different topologies runs in serial, however. It is therefore always preferable to use <code>generate()</code> or <code>assign_topologies(...)</code> if possible.</p>"},{"location":"usage/library/diagrams/#using-diagram-objects","title":"Using Diagram Objects","text":"<p>When producing diagrams with a <code>DiagramGenerator</code>, it returns a <code>DiagramContainer</code> object, which is a smart container for the internal <code>Diagram</code><sup>1</sup> objects. To minimize FeynGraph's memory footprint, these internal <code>Diagram</code> objects carry as little information as possible, making them hard and unpleasant to use for further processing. For this reason, the FeynGraph Rust library provides the View objects, which wrap the internal representation with a more user-friendly interface. The Python objects correspond to these view objects, not the underlying internal Rust representation.</p> <p>When accessing a diagram from a <code>DiagramContainer</code>, it is automatically converted to a <code>DiagramView</code>, making the internal representation largely invisible.</p> <ol> <li> <p>Note that this refers to the Rust <code>Diagram</code> object, not the Python object.\u00a0\u21a9</p> </li> </ol>"},{"location":"usage/library/drawing/","title":"Automatic Drawing of Topologies and Diagrams","text":"<p>Info</p> <p>The drawing module is in principle fully functional, but not fully tuned. Flaws like part of the drawing reaching outside of the bounding box, imperfect layout, etc. are to be expected currently.</p> <p>Since the easiest method to examine Feynman diagrams is by inspecting them visually, FeynGraph provides functions for the automatic layouting and drawing of topologies and diagrams. FeynGraph currently supports two formats:</p> <ul> <li>TikZ: per-diagram output of a standalone <code>.tikz</code> file which can be directly imported in a LaTeX document via TikZ or modified with <code>TikZiT</code>. This requires the additional <code>feyngraph.tikzdefs</code> and <code>feyngraph.tikzstyles</code> files which are distributed in <code>&lt;prefix&gt;/share/FeynGraph</code>.</li> <li>SVG: per-diagram output of a standalone <code>.svg</code> file or a single <code>.svg</code> file with large canvas containing multiple diagrams in a grid.</li> </ul> <p>Drawing functions are provided by the <code>Topology</code> and <code>Diagram</code>(<code>View</code>) objects for drawing of a single diagram and by the respective container objects for drawing of multiple diagrams.</p> <p>Example</p>  Python Rust <pre><code>from feyngraph import generate_diagrams\ndiags = generate_diagrams([\"u\", \"u~\"], [\"g\", \"g\"], 0)\ndiags.draw_svg(list(range(len(diags))))\n</code></pre> <pre><code>use feyngraph::generate_diagrams;\nlet diags = generate_diagrams([\"u\", \"u~\"], [\"g\", \"g\"], 0, None, None);\ndiags.draw_svg(..diags.len());\n</code></pre> <p> Resulting automatically drawn Feynman diagrams </p> <p>Example</p>  Python Rust <pre><code>from feyngraph.topology import TopologyGenerator, TopologySelector, TopologyModel\ns = TopologySelector()\ns.select_on_shell()\ns.select_self_loops(0)\ntopos = TopologyGenerator(4, 3, TopologyModel([3, 4]), selector = s).generate()\ntopos.draw([0, 1, 2])\n</code></pre> <pre><code>use feyngraph::{model::TopologyModel, topology::{TopologyGenerator, TopologySelector}};\nlet mut s = TopologySelector::new();\ns.select_on_shell();\ns.select_self_loops(0);\nlet topos = TopologyGenerator::new(4, 3, TopologyModel::from(vec![3, 4]), Some(s)).generate();\ntopos.draw(..3);\n</code></pre> <p> Resulting automatically drawn Topologies </p> <p>Tip</p> <p>The Python types implement the <code>_repr_svg_</code> method, therefore the respective objects are drawn automatically when using a Jupyter notebook. Only the first 100 topologies/diagrams of a container object are drawn with the <code>_repr_svg_</code> method.</p>"},{"location":"usage/library/topologies/","title":"Generating Topologies","text":"<p>Tip</p> <p>If no manual intervention into the topology generation is needed, the <code>DiagramGenerator</code> can automatically perform the topology generation step.</p> <p>The first step in FeynGraph's workflow is to generate the undirected graphs possibly contributing to the physical process, called topologies. The topologies encapsulate the topological information and can later be assigned particles and vertices from the model to produce Feynman diagrams.</p>"},{"location":"usage/library/topologies/#topology-models","title":"Topology Models","text":"<p>Since the topologies only contain topological information, no physical model is needed at this stage. The required information is supplied via a <code>TopologyModel</code>, which can be either derived from a physical model or created from a list of allowed node degrees:</p>  Python Rust <pre><code>from feyngraph import Model\nfrom feyngraph.topology import TopologyModel\nsm = Model()\nassert(sm.as_topology_model(), TopologyModel([3, 4]))\n</code></pre> <pre><code>use feyngraph::{Model, topology::TopologyModel};\nlet sm = Model::default();\nassert_eq!(TopologyModel::from(&amp;sm), TopologyModel::from(vec![3, 4]));\n</code></pre> <p>The allowed node degrees are the numbers of legs that can be attached to a single node, e.g. <code>[3, 4]</code> in a renormalizable theory. Mixing propagators, i.e. node degree <code>2</code>, are currently not supported.</p>"},{"location":"usage/library/topologies/#filtering-topologies","title":"Filtering Topologies","text":"<p>Often only a subset of all possible topologies is of interest, for this purpose FeynGraph provides the <code>TopologySelector</code> object to restrict the topology generation. As the name indicates, only topologies selected by the <code>TopologySelector</code> are kept, all topologies not selected are filtered away. There are several predefined selection criteria, see the API reference for a list. The same criterion can be added multiple times with different values, the <code>TopologySelector</code> will then select topologies satisfying any of the given values. If several different criteria are given, the topology is required to fulfill all of them.</p> <p>In addition to predefined criteria, the <code>TopologySelector</code> also supports fully custom selection functions. Custom functions can be added through the <code>add_custom_function</code> method, which takes as only input a function mapping a topology to a <code>bool</code>. The topology is selected if the custom function returns <code>True</code> and filtered if it returns <code>False</code>.</p> <p>Example</p> <p>Consider the 2-loop 4-point topologies in a theory with node degrees <code>[3, 4, 5, 6]</code>. Say we are interested only in \\(s\\)-channel topologies containing exactly one 4-leg node and one 6-leg node. The constraint on the node degrees can be encoded as a node partition criterion, which is the set of counts of the node degrees. The node partition in this example therefore is <code>[(4, 1), (6, 1)]</code>. The \\(s\\)-channel constraint cannot be encoded through any of the predefined criteria, therefore a custom function is used. This function checks for nodes <code>0</code> and <code>1</code> being attached to the same node.</p>  Python Rust <pre><code>from feyngraph.topology import TopologySelector, Topology\n\ndef s_channel(topo: Topology) -&gt; bool:\n  return any(\n    0 in node.adjacent() and 1 in node.adjacent() for node in topo.nodes()\n  )\n\ns = TopologySelector()\ns.add_node_partition([(4, 1), (6, 1)])\ns.add_custom_function(s_channel)\n</code></pre> <pre><code>use feyngraph::topology::{Topology, filter::TopologySelector};\n\nlet mut s = TopologySelector::new();\ns.add_node_partition(vec![(4, 1), (6, 1)]);\ns.add_custom_function(Arc::new(\n  |t| t.nodes_iter().any(|n| n.adjacent_nodes.contains(&amp;0) &amp;&amp; n.adjacent_nodes.contains(&amp;1))\n));\n</code></pre>"},{"location":"usage/library/topologies/#generating-topologies_1","title":"Generating Topologies","text":"<p>The step of actually generating the topologies is handled by the <code>TopologyGenerator</code>. The <code>TopologyGenerator</code> requires three inputs, the number of external legs, the number of loops in the topology and a <code>TopologyModel</code>. If only a subset of the topologies is to be kept, a <code>TopologySelector</code> can optionally be supplied to the <code>TopologyGenerator</code>.</p> <p>Example</p>  Python Rust <pre><code>from feyngraph.topology import TopologyGenerator, TopologySelector, Topology\n\ntopo_gen = TopologyGenerator(4, 2, TopologyModel([3, 4, 5, 6]))\ntopos = topo_gen.generate()\nassert(len(topos) == 2863)\n\ndef s_channel(topo: Topology) -&gt; bool:\n    return any(\n      0 in node.adjacent() and 1 in node.adjacent() for node in topo.nodes()\n    )\n\ns = TopologySelector()\ns.add_node_partition([(4, 1), (6, 1)])\ns.add_custom_function(s_channel)\n\ntopo_gen = TopologyGenerator(4, 2, TopologyModel([3, 4, 5, 6]), selector = s)\ntopos = topo_gen.generate()\nassert(len(topos) == 9)\n</code></pre> <pre><code>use feyngraph::topology::{TopologyGenerator, filter::TopologyFilter};\n\nlet mut topo_gen = TopologyGenerator::new(4, 2, TopologyModel::from(vec![3, 4, 5, 6]), None);\nlet topos = topo_gen.generate();\nassert_eq!(topos.len(), 2863);\n\nlet mut s = TopologySelector::new();\ns.add_node_partition(vec![(4, 1), (6, 1)]);\ns.add_custom_function(Arc::new(\n  |t| t.nodes_iter().any(|n| n.adjacent_nodes.contains(&amp;0) &amp;&amp; n.adjacent_nodes.contains(&amp;1))\n));\n\nlet mut topo_gen = TopologyGenerator::new(4, 2, TopologyModel::from(vec![3, 4, 5, 6]), s);\nlet topos = topo_gen.generate();\nassert_eq!(topos.len(), 9);\n</code></pre> <p>The <code>generate()</code> function returns a <code>TopologContainer</code>, which is a smart container holding the generated <code>Topology</code> objects. It can be used like a <code>list</code>/<code>Vec</code> in the respective language.</p>"}]}